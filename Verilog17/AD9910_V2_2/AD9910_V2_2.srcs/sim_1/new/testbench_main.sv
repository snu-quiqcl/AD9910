`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2020/08/09 13:37:10
// Design Name: 
// Module Name: testbench_main
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module testbench_main;

logic Uart_RXD;
logic Uart_TXD;
logic CLK100MHZ;
logic BTN0;
logic BTN1;
logic BTN2;
logic ck_io_39, ck_io_38, ck_io_37; // DAC0 
logic ck_io_36, ck_io_35, ck_io_34; // DAC1
logic ck_io_6; // LDAC
logic ja_7; //powerdown
wire ja_6; //sdio
logic ja_5; //csb
logic ja_4; //reset
logic ja_3; // sclk
logic ja_2; // powerdown2
wire ja_1; //sdio2
logic ja_0; // csb2
logic jb_0;
logic jb_1;
logic jb_2;
logic jb_3;
logic jb_4;
logic jb_5;
logic jb_6;
logic jb_7;
logic [5:2] led;
logic led0_r;
logic led0_g;
logic led0_b;
logic led1_r;
logic led1_g;
logic led1_b;
logic d5, d4, d3, d2, d1, d0;

main main0(
    .Uart_RXD(Uart_RXD),
    .Uart_TXD(Uart_TXD),
    .CLK100MHZ(CLK100MHZ),
    .BTN0(BTN0),
    .BTN1(BTN1),
    .BTN2(BTN2),
    .ck_io_39(ck_io_39), 
    .ck_io_38(ck_io_38), 
    .ck_io_37(ck_io_37), // DAC0 
    .ck_io_36(ck_io_36), 
    .ck_io_35(ck_io_35), 
    .ck_io_34(ck_io_34), // DAC1
    .ck_io_6(ck_io_6), // LDAC
    .ja_7(ja_7), //powerdown
    .ja_5(ja_5), //csb
    .ja_4(ja_4), //reset
    .ja_3(ja_3), // sclk
    .ja_2(ja_2), // powerdown2
    .ja_0(ja_0), // csb2
    .jb_0(jb_0),
    .jb_1(jb_1),
    .jb_2(jb_2),
    .jb_3(jb_3),
    .jb_4(jb_4),
    .jb_5(jb_5),
    .jb_6(jb_6),
    .jb_7(jb_7),
    .led(led),
    .led0_r(led0_r),
    .led0_g(led0_g),
    .led0_b(led0_b),
    .led1_r(led1_r),
    .led1_g(led1_g),
    .led1_b(led1_b),
    .d5(d5), 
    .d4(d4), 
    .d3(d3), 
    .d2(d2), 
    .d1(d1), 
    .d0(d0) // For debugging purpose    
    );
   
always begin
    #5
    CLK100MHZ = ~CLK100MHZ;
end

parameter MAX_LENGTH = 256;

logic [MAX_LENGTH-1:0] TEMP;
logic [9:0] TEMP_S;
integer i;
initial begin
    //TEMP = (2**256-1) & 256'b 00001010 00001101 11001100 11001100 11001100 00001100 00000000 00000000 11111111 00111111 00001110 00111001 01100001 00110001 00100011;
    //TEMP = (2**256-1) & 256'b 1000010100 1000011010 1110011000 1110011000 1110011000 1000011000 1000000000 1000000000 1111111110 1001111110 1000011100 1001110010 1011000010 1001100010 1001000110;
    TEMP = (2**256 - 1 - (2**150-1) ) + 256'b100001010010000110101110011000111001100011100110001000011000100000000010000000001111111110100111111010000111001001110010101100001010011000101001000110;
    Uart_RXD = 1;
    CLK100MHZ = 0;
    BTN0 = 0;
    BTN1 = 0;
    BTN2 = 0;
    jb_0 = 0;
    jb_1 = 0;
    jb_2 = 0;
    jb_3 = 0;
    jb_4 = 0;
    jb_5 = 0;
    jb_6 = 0;
    jb_7 = 0;
    
    /*
    TEMP_S = 10'b1001000110;
    
    #100000
    for( i = 0; i <= 9 ; i++ ) begin
                #17361
                Uart_RXD = TEMP_S[i];
    end
    */
    
    ////
    //** AD9910 SIM
    ////
    #100000
    for( i = 0; i <= MAX_LENGTH - 1 ; i++ ) begin
        #17361
        Uart_RXD = TEMP[i];
    end
    Uart_RXD = 1;
    
    #50000;
    
    //TEMP =256'b 00001010 00001101 01000111 01000101 01010010 00100000 01010011 01000100 01000100 00100000 01000101 01010100 01001001 01010010 01010111 01100100 00100001;
    //TEMP =256'b 1000010100 1000011010 1010001110 1010001010 1010100100 1001000000 1010100110 1010001000 1010001000 1001000000 1010001010 1010101000 1010010010 1010100100 1010101110 1011001000 1001000010;
    TEMP =((2**256 - 1) - (2**170 - 1)) + 256'b10000101001000011010101000111010100010101010100100100100000010101001101010001000101000100010010000001010001010101010100010100100101010100100101010111010110010001001000010;
    for( i = 0; i <= MAX_LENGTH - 1 ; i++ ) begin
            #17361
            Uart_RXD = TEMP[i];
    end
    
    Uart_RXD = 1;
    #50000
    
    //TEMP = 256'b00001010 00001101 01000101 01010100 01000001 01000100 01010000 01010101 00100000 01001111 01001001 00100000 01010011 01000100 01000100 01100100 00100001;
    //TEMP = 256'b1000010100 1000011010 1010001010 1010101000 1010000010 1010001000 1010100000 1010101010 1001000000 1010011110 1010010010 1001000000 1010100110 1010001000 1010001000 1011001000 1001000010;
    TEMP = ((2**256 - 1) - (2**170 - 1)) +  256'b10000101001000011010101000101010101010001010000010101000100010101000001010101010100100000010100111101010010010100100000010101001101010001000101000100010110010001001000010;
    for( i = 0; i <= MAX_LENGTH - 1 ; i++ ) begin
                #17361
                Uart_RXD = TEMP[i];
    end
    Uart_RXD = 1;
    
    
    ////
    //***** AD9912 SIM
    ////
    /*
    //TEMP =  256'b00001010 00001101 11001100 11001100 11001100 11001100 11001100 00001100 10101011 01100001 00111000 00111001 00110001 00100011;
    //TEMP =  256'b1000010100 1000011010 1110011000 1110011000 1110011000 1110011000 1110011000 1000011000 1101010110 1011000010 1001110000 1001110010 1001100010 1001000110;
    TEMP = ((2**256 - 1) - (2**140 - 1)) + 256'b10000101001000011010111001100011100110001110011000111001100011100110001000011000110101011010110000101001110000100111001010011000101001000110;
    #100000
    for( i = 0; i <= MAX_LENGTH - 1 ; i++ ) begin
        #17361
        Uart_RXD = TEMP[i];
    end
    Uart_RXD = 1;
    */
end

endmodule
